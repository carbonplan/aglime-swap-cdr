#!/usr/bin/env python3

import hashlib
import itertools
import os
import re
import shutil
import ssl
import sys
import threading
import time
import urllib.request
from platform import python_version
from urllib.error import HTTPError, URLError

################################################################
#
# Generated by: NCAR Climate Data Gateway
# Created: 2024-05-01T16:21:45-06:00
#
# Your download selection includes data that might be secured using API Token based
# authentication. Therefore, this script can have your api-token. If you
# re-generate your API Token after you download this script, the download will
# fail. If that happens, you can either re-download the script or you can edit
# this script replacing the old API Token with the new one. View your API token
# by going to "Account Home":
#
# https://www.earthsystemgrid.org/account/user/account-home.html
#
# and clicking on the "API Token" link under "Personal Account". You will be asked
# to log into the application before you can view your API Token.
#
# Usage: python3 python-ucar.cgd.cesm2le.atm.proc.monthly_ave.PRECT-20240501T1621.py
# Version: 1.0.1
#
# Dataset
# ucar.cgd.cesm2le.atm.proc.monthly_ave.PRECT
# 6e336ba8-545e-42d5-8e8b-c0a31e642bcb
# https://www.earthsystemgrid.org/dataset/ucar.cgd.cesm2le.atm.proc.monthly_ave.PRECT.html
# https://www.earthsystemgrid.org/dataset/id/6e336ba8-545e-42d5-8e8b-c0a31e642bcb.html
#
# Dataset Version
# 1
# 6fdd2c1b-c391-4f11-a205-7b6d5a61bf04
# https://www.earthsystemgrid.org/dataset/ucar.cgd.cesm2le.atm.proc.monthly_ave.PRECT/version/1.html
# https://www.earthsystemgrid.org/dataset/version/id/6fdd2c1b-c391-4f11-a205-7b6d5a61bf04.html
#
################################################################

print("Please email feedback to esg-support@earthsystemgrid.org.\n")

data = [
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.185001-185912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.185001-185912.nc",
        "bytes": "20992473",
        "md5Checksum": "b87ac7c0d35ba55cd1b7b282ed51d9fd",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.186001-186912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.186001-186912.nc",
        "bytes": "20995645",
        "md5Checksum": "c53508ca3a962855ae507fca091ed84e",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.187001-187912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.187001-187912.nc",
        "bytes": "20991577",
        "md5Checksum": "a0f5db18ec24d639dca2c39acc4721f7",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.188001-188912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.188001-188912.nc",
        "bytes": "20999762",
        "md5Checksum": "c075e7668f2c6dbe2ee0caf047523614",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.189001-189912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.189001-189912.nc",
        "bytes": "20997639",
        "md5Checksum": "158ce01daa2fd2072a992fab1c790e13",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.190001-190912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.190001-190912.nc",
        "bytes": "20998041",
        "md5Checksum": "9ef908f219d33ee48593d7df053c28bd",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.191001-191912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.191001-191912.nc",
        "bytes": "20989263",
        "md5Checksum": "3e202afd56b0f177a2a354481f9e2cfe",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.192001-192912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.192001-192912.nc",
        "bytes": "20996437",
        "md5Checksum": "9b4fc657263c50c20f63258189d96816",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.193001-193912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.193001-193912.nc",
        "bytes": "20995700",
        "md5Checksum": "a8fd2d14925089ccdc73a7f62977e6ca",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.194001-194912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.194001-194912.nc",
        "bytes": "20997756",
        "md5Checksum": "085e36c7778c370f333f2ecaddc38dd4",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.195001-195912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.195001-195912.nc",
        "bytes": "21000234",
        "md5Checksum": "11fcd069cc7bcdfb4886516004c1eb0d",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.196001-196912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.196001-196912.nc",
        "bytes": "20996435",
        "md5Checksum": "3498371a3301fa2d5881536ececc61fa",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.197001-197912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.197001-197912.nc",
        "bytes": "20995388",
        "md5Checksum": "46207bce8df78a889a417b3f30e824f3",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.198001-198912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.198001-198912.nc",
        "bytes": "21003937",
        "md5Checksum": "06bdd915289effbe75748795caa66a81",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.199001-199912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.199001-199912.nc",
        "bytes": "20999076",
        "md5Checksum": "51f38c59eb3eef6389854d958437ced9",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.200001-200912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.200001-200912.nc",
        "bytes": "21000080",
        "md5Checksum": "35c4831eef5f85c0d8019ca5eefd3077",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.201001-201412.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.201001-201412.nc",
        "bytes": "10541723",
        "md5Checksum": "f7dbc296f57fa8495ad94b847875cd1d",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.201501-202412.nc",
        "filename": "b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.201501-202412.nc",
        "bytes": "21001830",
        "md5Checksum": "5909b367b89e0ad4be23d7cab6d02d81",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.202501-203412.nc",
        "filename": "b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.202501-203412.nc",
        "bytes": "21004833",
        "md5Checksum": "2dae06904f55c2ea5db48d78b68fbdbd",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.203501-204412.nc",
        "filename": "b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.203501-204412.nc",
        "bytes": "21001770",
        "md5Checksum": "a59ddb4aed9ad9d184c6d95f10295d1d",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.204501-205412.nc",
        "filename": "b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.204501-205412.nc",
        "bytes": "21004364",
        "md5Checksum": "fd0aabbcbcb86c1fe2845c00229b3fdb",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.205501-206412.nc",
        "filename": "b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.205501-206412.nc",
        "bytes": "21004943",
        "md5Checksum": "c5a1b54309c060a24da33e8d40631ddb",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.206501-207412.nc",
        "filename": "b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.206501-207412.nc",
        "bytes": "21008843",
        "md5Checksum": "71ee215edc0a68cd75533760a0be55ce",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.207501-208412.nc",
        "filename": "b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.207501-208412.nc",
        "bytes": "21007059",
        "md5Checksum": "14321d9efa26f8eff5b28bb800aefcb2",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.208501-209412.nc",
        "filename": "b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.208501-209412.nc",
        "bytes": "21007397",
        "md5Checksum": "d68ed8d3331da2a15b04a3b2cecdb83b",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/PRECT/b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.209501-210012.nc",
        "filename": "b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.PRECT.209501-210012.nc",
        "bytes": "12650838",
        "md5Checksum": "f31beabe8e5e27b517909fd79aca21fe",
    },
]


def main(data):
    args = processArguments()

    for d in data:
        executeDownload(Download(args, d))


def processArguments():
    args = {}
    args.update({"apiToken": "cCWiv1YLhFQ7dk5OaoVxSKaE4Byzobnvb5DtqS9L"})
    args.update(
        {
            "userAgent": "python/{}/gateway/{}".format(
                python_version(), "4.4.6-20240402-174931"
            )
        }
    )
    args.update({"attemptMax": 10})
    args.update({"initialSleepSeconds": 10})
    args.update({"sleepMultiplier": 3})
    args.update({"sleepMaxSeconds": 900})
    args.update({"insecure": False})

    if "-k" in sys.argv or "--insecure" in sys.argv:
        args.update({"insecure": True})

    if "-h" in sys.argv or "--help" in sys.argv:
        print("Usage: {} [options...]".format(sys.argv[0]))
        print(" -h, --help        Show usage")
        print(
            " -k, --insecure    Allow insecure server connections (no certificate check) when using SSL"
        )
        exit(0)

    return args


def executeDownload(download):
    if not os.path.isfile(download.filename):
        attemptAndValidateDownload(download)
        moveDownload(download)
    else:
        download.success = True
        download.valid = True

    reportDownload(download)


def moveDownload(download):
    if download.success and (download.valid or download.vwarning):
        os.rename(download.filenamePart, download.filename)


def reportDownload(download):
    if download.success and download.valid:
        print("{} download successful".format(download.filename))

    if download.success and not download.valid and download.vwarning:
        print(
            "{} download validation warning: {}".format(
                download.filename, download.vwarning
            )
        )

    if download.success and not download.valid and download.verror:
        print(
            "{} download validation error: {}".format(
                download.filename, download.verror
            )
        )

    if not download.success and download.error:
        print("{} download failed: {}".format(download.filename, download.error))


def attemptAndValidateDownload(download):
    while download.attempt:
        downloadFile(download)

    if download.success:
        validateFile(download)


def downloadFile(download):
    try:
        startOrResumeDownload(download)
    except HTTPError as error:
        handleHTTPErrorAttempt(download, error)
    except URLError as error:
        handleRecoverableAttempt(download, error)
    except TimeoutError as error:
        handleRecoverableAttempt(download, error)
    except Exception as error:
        handleIrrecoverableAttempt(download, error)
    else:
        handleSuccessfulAttempt(download)


def startOrResumeDownload(download):
    startAnimateDownload("{} downloading:".format(download.filename))

    if os.path.isfile(download.filenamePart):
        resumeDownloadFile(download)
    else:
        startDownloadFile(download)


def startAnimateDownload(message):
    global animateMessage
    global animateOn

    animateMessage = message
    animateOn = True

    # making the animation run as a daemon thread allows it to
    # exit when the parent (main) is terminated or killed
    t = threading.Thread(daemon=True, target=animateDownload)
    t.start()


def stopAnimateDownload(outcome):
    global animateOutcome
    global animateOn

    animateOutcome = outcome
    animateOn = False

    # wait for animation child process to stop before any parent print
    time.sleep(0.3)


def animateDownload():
    global animateMessage
    global animateOutcome
    global animateOn

    for d in itertools.cycle([".  ", ".. ", "...", "   "]):
        if not animateOn:
            print("\r{} {}".format(animateMessage, animateOutcome), flush=True)
            break

        print("\r{} {}".format(animateMessage, d), end="", flush=True)
        time.sleep(0.2)


def resumeDownloadFile(download):
    request = createRequest(download, createResumeHeaders(download))
    readFile(download, request)


def startDownloadFile(download):
    request = createRequest(download, createStartHeaders(download))
    readFile(download, request)


def createResumeHeaders(download):
    headers = createStartHeaders(download)
    headers.update(createRangeHeader(download))

    return headers


def createRequest(download, headers):
    request = urllib.request.Request(download.url, headers=headers)

    return request


def createStartHeaders(download):
    headers = {}
    headers.update(createUserAgentHeader(download))

    if download.apiToken:
        headers.update(createAuthorizationHeader(download))

    return headers


def createUserAgentHeader(download):
    return {"User-agent": download.userAgent}


def createAuthorizationHeader(download):
    return {"Authorization": "api-token {}".format(download.apiToken)}


def createRangeHeader(download):
    start = os.path.getsize(download.filenamePart)
    header = {"Range": "bytes={}-".format(start)}

    return header


def readFile(download, request):
    context = createSSLContext(download)

    with (
        urllib.request.urlopen(request, context=context) as response,
        open(download.filenamePart, "ab") as fh,
    ):
        collectResponseHeaders(download, response)
        shutil.copyfileobj(response, fh)


def createSSLContext(download):
    # See:
    #      https://docs.python.org/3/library/urllib.request.html
    #      https://docs.python.org/3/library/http.client.html#http.client.HTTPSConnection
    #      https://docs.python.org/3/library/ssl.html#ssl.SSLContext
    #
    # Excerpts:
    #      If context is specified it must be a ssl.SSLContext instance...
    #      http.client.HTTPSConnection performs all the necessary certificate and hostname checks by default.

    if download.insecure:
        return ssl._create_unverified_context()

    return None


def collectResponseHeaders(download, response):
    download.responseHeaders = response.info()
    if download.responseHeaders.get("ETag"):
        download.etag = download.responseHeaders.get("ETag").strip('"')


def handleHTTPErrorAttempt(download, httpError):
    if httpError.code == 416:  # 416 is Range Not Satisfiable
        # likely the file completely downloaded and validation was interrupted,
        # therefore calling it successfully downloaded and allowing validation
        # to say otherwise
        handleSuccessfulAttempt(download)
    else:
        handleRecoverableAttempt(download, httpError)


def handleRecoverableAttempt(download, error):
    stopAnimateDownload("error")

    print(
        "failure on attempt {} downloading {}: {}".format(
            download.attemptNumber, download.filename, error
        )
    )

    if download.attemptNumber < download.attemptMax:
        sleepBeforeNextAttempt(download)
        download.attemptNumber += 1
    else:
        download.attempt = False
        download.error = error


def sleepBeforeNextAttempt(download):
    sleepSeconds = download.initialSleepSeconds * (
        download.sleepMultiplier ** (download.attemptNumber - 1)
    )

    if sleepSeconds > download.sleepMaxSeconds:
        sleepSeconds = download.sleepMaxSeconds

    print(
        "waiting {} seconds before next attempt to download {}".format(
            sleepSeconds, download.filename
        )
    )
    time.sleep(sleepSeconds)


def handleIrrecoverableAttempt(download, error):
    stopAnimateDownload("error")

    download.attempt = False
    download.error = error


def handleSuccessfulAttempt(download):
    stopAnimateDownload("done")

    download.attempt = False
    download.success = True


def validateFile(download):
    try:
        validateAllSteps(download)
    except InvalidDownload as error:
        download.valid = False
        download.vwarning = str(error)
    except Exception as error:
        download.valid = False
        download.verror = error
    else:
        download.valid = True


def validateAllSteps(download):
    verrorData = validatePerData(download)
    verrorEtag = validatePerEtag(download)
    verrorStale = validateStaleness(download)

    if verrorData and verrorEtag:
        raise verrorData

    if verrorStale:
        raise verrorStale


def validatePerData(download):
    try:
        validateBytes(download)
        validateChecksum(download)
    except InvalidDownload as error:
        return error
    else:
        return None


def validateBytes(download):
    size = os.path.getsize(download.filenamePart)
    if not download.bytes == size:
        raise InvalidSizeValue(download, size)


def validateChecksum(download):
    if download.md5Checksum:
        md5Checksum = readMd5Checksum(download)
        if not download.md5Checksum == md5Checksum:
            raise InvalidChecksumValue(download, md5Checksum)
    else:
        raise UnableToPerformChecksum(download)


def readMd5Checksum(download):
    hash_md5 = hashlib.md5()

    with open(download.filenamePart, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)

    return hash_md5.hexdigest()


def validatePerEtag(download):
    try:
        validateChecksumEtag(download)
    except InvalidDownload as error:
        return error
    else:
        return None


def validateChecksumEtag(download):
    if isEtagChecksum(download):
        md5Checksum = readMd5Checksum(download)
        if not download.etag == md5Checksum:
            raise InvalidChecksumValuePerEtag(download, md5Checksum)
    else:
        raise UnableToPerformChecksum(download)


def isEtagChecksum(download):
    return download.etag and re.fullmatch(r"[a-z0-9]+", download.etag)


def validateStaleness(download):
    try:
        validateStaleChecksum(download)
    except InvalidDownload as error:
        return error
    else:
        return None


def validateStaleChecksum(download):
    if isEtagChecksum(download):
        if not download.md5Checksum or download.md5Checksum != download.etag:
            raise StaleChecksumValue(download)


class InvalidDownload(Exception):
    pass


class InvalidSizeValue(InvalidDownload):
    def __init__(self, download, actual):
        super().__init__(
            "invalid byte size: downloaded file is {} bytes but should be {}".format(
                actual, download.bytes
            )
        )


class InvalidChecksumValue(InvalidDownload):
    def __init__(self, download, actual):
        super().__init__(
            "invalid checksum: downloaded file is {} but should be {}".format(
                actual, download.md5Checksum
            )
        )


class InvalidChecksumValuePerEtag(InvalidDownload):
    def __init__(self, download, actual):
        super().__init__(
            "invalid checksum: downloaded file is {} but should be {} according to server".format(
                actual, download.etag
            )
        )


class UnableToPerformChecksum(InvalidDownload):
    def __init__(self, download):
        super().__init__("cannot verify checksum")


class StaleChecksumValue(InvalidDownload):
    def __init__(self, download):
        super().__init__("checksum value has changed")


class Download:
    def __init__(self, args, datum):
        self.apiToken = args.get("apiToken")
        self.userAgent = args.get("userAgent")
        self.attemptMax = args.get("attemptMax")
        self.initialSleepSeconds = args.get("initialSleepSeconds")
        self.sleepMultiplier = args.get("sleepMultiplier")
        self.sleepMaxSeconds = args.get("sleepMaxSeconds")
        self.insecure = args.get("insecure")

        self.url = datum.get("url")
        self.filename = datum.get("filename")
        self.bytes = int(datum.get("bytes"))
        self.md5Checksum = datum.get("md5Checksum")

        self.filenamePart = self.filename + ".part"
        self.success = False
        self.attempt = True
        self.attemptNumber = 1
        self.responseHeaders = {}
        self.etag = None
        self.error = None
        self.valid = False
        self.vwarning = None
        self.verror = None

    def __str__(self):
        return f"url: {self.url}, filename: {self.filename}, bytes: {self.bytes}, md5Checksum: {self.md5Checksum}"


if __name__ == "__main__":
    main(data)
