#!/usr/bin/env python3

import hashlib
import itertools
import os
import re
import shutil
import ssl
import sys
import threading
import time
import urllib.request
from platform import python_version
from urllib.error import HTTPError, URLError

################################################################
#
# Generated by: NCAR Climate Data Gateway
# Created: 2024-05-01T16:28:53-06:00
#
# Your download selection includes data that might be secured using API Token based
# authentication. Therefore, this script can have your api-token. If you
# re-generate your API Token after you download this script, the download will
# fail. If that happens, you can either re-download the script or you can edit
# this script replacing the old API Token with the new one. View your API token
# by going to "Account Home":
#
# https://www.earthsystemgrid.org/account/user/account-home.html
#
# and clicking on the "API Token" link under "Personal Account". You will be asked
# to log into the application before you can view your API Token.
#
# Usage: python3 python-ucar.cgd.cesm2le.atm.proc.monthly_ave.QFLX-20240501T1628.py
# Version: 1.0.1
#
# Dataset
# ucar.cgd.cesm2le.atm.proc.monthly_ave.QFLX
# e863dd28-c328-46b7-ad85-e691b1c24a71
# https://www.earthsystemgrid.org/dataset/ucar.cgd.cesm2le.atm.proc.monthly_ave.QFLX.html
# https://www.earthsystemgrid.org/dataset/id/e863dd28-c328-46b7-ad85-e691b1c24a71.html
#
# Dataset Version
# 1
# a774d8a9-391f-44fa-8681-6eaa78d3138d
# https://www.earthsystemgrid.org/dataset/ucar.cgd.cesm2le.atm.proc.monthly_ave.QFLX/version/1.html
# https://www.earthsystemgrid.org/dataset/version/id/a774d8a9-391f-44fa-8681-6eaa78d3138d.html
#
################################################################

print("Please email feedback to esg-support@earthsystemgrid.org.\n")

data = [
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.185001-185912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.185001-185912.nc",
        "bytes": "20627462",
        "md5Checksum": "b5b8ea861cca0df6097245e75b8d47b0",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.186001-186912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.186001-186912.nc",
        "bytes": "20629375",
        "md5Checksum": "94dbcc38f684093cae1d50d01800d4ee",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.187001-187912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.187001-187912.nc",
        "bytes": "20628521",
        "md5Checksum": "1015657ff7afd22d39df23fc6901e152",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.188001-188912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.188001-188912.nc",
        "bytes": "20631121",
        "md5Checksum": "b9296d43659e4006c726257d329604f0",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.189001-189912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.189001-189912.nc",
        "bytes": "20626460",
        "md5Checksum": "b5de10faeb7f5a9d0e970f10630f50f6",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.190001-190912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.190001-190912.nc",
        "bytes": "20626353",
        "md5Checksum": "55715d6453ab16935f9d346750f0033a",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.191001-191912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.191001-191912.nc",
        "bytes": "20626634",
        "md5Checksum": "6005515207eeaee23c44218681965d5a",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.192001-192912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.192001-192912.nc",
        "bytes": "20629426",
        "md5Checksum": "f9b12f6cada7331a52376ed05f8f3136",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.193001-193912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.193001-193912.nc",
        "bytes": "20629789",
        "md5Checksum": "a39939bc52742b5427586128af54aad7",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.194001-194912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.194001-194912.nc",
        "bytes": "20624742",
        "md5Checksum": "a4a9e31cfe74c768375dada2f8d93dbb",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.195001-195912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.195001-195912.nc",
        "bytes": "20623995",
        "md5Checksum": "acc4bdd77d3f4ae29816fd96982ebe5f",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.196001-196912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.196001-196912.nc",
        "bytes": "20632275",
        "md5Checksum": "bf90b8617269193b342edbc28e3a4c29",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.197001-197912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.197001-197912.nc",
        "bytes": "20638841",
        "md5Checksum": "7c2b8c86bf73197ddcc883faea1d433f",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.198001-198912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.198001-198912.nc",
        "bytes": "20632665",
        "md5Checksum": "c5e9ce4049420a8e277c575c3094899b",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.199001-199912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.199001-199912.nc",
        "bytes": "20632210",
        "md5Checksum": "78f5bda6470a5658987e757c4abc4dea",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.200001-200912.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.200001-200912.nc",
        "bytes": "20616957",
        "md5Checksum": "ba01d071481097400b60750782dc07f4",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.201001-201412.nc",
        "filename": "b.e21.BHISTcmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.201001-201412.nc",
        "bytes": "10347985",
        "md5Checksum": "70cddace3ec051d72ba2ae9d2a3c512f",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.201501-202412.nc",
        "filename": "b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.201501-202412.nc",
        "bytes": "20619666",
        "md5Checksum": "7356e72b2cf8b434b37b978c96b6b517",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.202501-203412.nc",
        "filename": "b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.202501-203412.nc",
        "bytes": "20615298",
        "md5Checksum": "22d6668b29b38808c0b276f319b30e6b",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.203501-204412.nc",
        "filename": "b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.203501-204412.nc",
        "bytes": "20610506",
        "md5Checksum": "6150de11c6e09bd050a089ce734bbd5d",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.204501-205412.nc",
        "filename": "b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.204501-205412.nc",
        "bytes": "20607929",
        "md5Checksum": "2712a3c1e5cd0dad3db88e0daafc5e6d",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.205501-206412.nc",
        "filename": "b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.205501-206412.nc",
        "bytes": "20609506",
        "md5Checksum": "900d289f15497c02fa31393fb11a6262",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.206501-207412.nc",
        "filename": "b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.206501-207412.nc",
        "bytes": "20598301",
        "md5Checksum": "395419e1d5884b070195c7d9bd1bebcd",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.207501-208412.nc",
        "filename": "b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.207501-208412.nc",
        "bytes": "20601046",
        "md5Checksum": "bb94bd4838e859f8f72e834bd335ab9f",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.208501-209412.nc",
        "filename": "b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.208501-209412.nc",
        "bytes": "20580734",
        "md5Checksum": "5172ecc12f13a86ff856ab1fd6910d03",
    },
    {
        "url": "https://tds.ucar.edu/thredds/fileServer/datazone/campaign/cgd/cesm/CESM2-LE/atm/proc/tseries/month_1/QFLX/b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.209501-210012.nc",
        "filename": "b.e21.BSSP370cmip6.f09_g17.LE2-1231.001.cam.h0.QFLX.209501-210012.nc",
        "bytes": "12389631",
        "md5Checksum": "594f9a6c086b8361da42fb1c01e9851b",
    },
]


def main(data):
    args = processArguments()

    for d in data:
        executeDownload(Download(args, d))


def processArguments():
    args = {}
    args.update({"apiToken": "cCWiv1YLhFQ7dk5OaoVxSKaE4Byzobnvb5DtqS9L"})
    args.update(
        {
            "userAgent": "python/{}/gateway/{}".format(
                python_version(), "4.4.6-20240402-174931"
            )
        }
    )
    args.update({"attemptMax": 10})
    args.update({"initialSleepSeconds": 10})
    args.update({"sleepMultiplier": 3})
    args.update({"sleepMaxSeconds": 900})
    args.update({"insecure": False})

    if "-k" in sys.argv or "--insecure" in sys.argv:
        args.update({"insecure": True})

    if "-h" in sys.argv or "--help" in sys.argv:
        print("Usage: {} [options...]".format(sys.argv[0]))
        print(" -h, --help        Show usage")
        print(
            " -k, --insecure    Allow insecure server connections (no certificate check) when using SSL"
        )
        exit(0)

    return args


def executeDownload(download):
    if not os.path.isfile(download.filename):
        attemptAndValidateDownload(download)
        moveDownload(download)
    else:
        download.success = True
        download.valid = True

    reportDownload(download)


def moveDownload(download):
    if download.success and (download.valid or download.vwarning):
        os.rename(download.filenamePart, download.filename)


def reportDownload(download):
    if download.success and download.valid:
        print("{} download successful".format(download.filename))

    if download.success and not download.valid and download.vwarning:
        print(
            "{} download validation warning: {}".format(
                download.filename, download.vwarning
            )
        )

    if download.success and not download.valid and download.verror:
        print(
            "{} download validation error: {}".format(
                download.filename, download.verror
            )
        )

    if not download.success and download.error:
        print("{} download failed: {}".format(download.filename, download.error))


def attemptAndValidateDownload(download):
    while download.attempt:
        downloadFile(download)

    if download.success:
        validateFile(download)


def downloadFile(download):
    try:
        startOrResumeDownload(download)
    except HTTPError as error:
        handleHTTPErrorAttempt(download, error)
    except URLError as error:
        handleRecoverableAttempt(download, error)
    except TimeoutError as error:
        handleRecoverableAttempt(download, error)
    except Exception as error:
        handleIrrecoverableAttempt(download, error)
    else:
        handleSuccessfulAttempt(download)


def startOrResumeDownload(download):
    startAnimateDownload("{} downloading:".format(download.filename))

    if os.path.isfile(download.filenamePart):
        resumeDownloadFile(download)
    else:
        startDownloadFile(download)


def startAnimateDownload(message):
    global animateMessage
    global animateOn

    animateMessage = message
    animateOn = True

    # making the animation run as a daemon thread allows it to
    # exit when the parent (main) is terminated or killed
    t = threading.Thread(daemon=True, target=animateDownload)
    t.start()


def stopAnimateDownload(outcome):
    global animateOutcome
    global animateOn

    animateOutcome = outcome
    animateOn = False

    # wait for animation child process to stop before any parent print
    time.sleep(0.3)


def animateDownload():
    global animateMessage
    global animateOutcome
    global animateOn

    for d in itertools.cycle([".  ", ".. ", "...", "   "]):
        if not animateOn:
            print("\r{} {}".format(animateMessage, animateOutcome), flush=True)
            break

        print("\r{} {}".format(animateMessage, d), end="", flush=True)
        time.sleep(0.2)


def resumeDownloadFile(download):
    request = createRequest(download, createResumeHeaders(download))
    readFile(download, request)


def startDownloadFile(download):
    request = createRequest(download, createStartHeaders(download))
    readFile(download, request)


def createResumeHeaders(download):
    headers = createStartHeaders(download)
    headers.update(createRangeHeader(download))

    return headers


def createRequest(download, headers):
    request = urllib.request.Request(download.url, headers=headers)

    return request


def createStartHeaders(download):
    headers = {}
    headers.update(createUserAgentHeader(download))

    if download.apiToken:
        headers.update(createAuthorizationHeader(download))

    return headers


def createUserAgentHeader(download):
    return {"User-agent": download.userAgent}


def createAuthorizationHeader(download):
    return {"Authorization": "api-token {}".format(download.apiToken)}


def createRangeHeader(download):
    start = os.path.getsize(download.filenamePart)
    header = {"Range": "bytes={}-".format(start)}

    return header


def readFile(download, request):
    context = createSSLContext(download)

    with (
        urllib.request.urlopen(request, context=context) as response,
        open(download.filenamePart, "ab") as fh,
    ):
        collectResponseHeaders(download, response)
        shutil.copyfileobj(response, fh)


def createSSLContext(download):
    # See:
    #      https://docs.python.org/3/library/urllib.request.html
    #      https://docs.python.org/3/library/http.client.html#http.client.HTTPSConnection
    #      https://docs.python.org/3/library/ssl.html#ssl.SSLContext
    #
    # Excerpts:
    #      If context is specified it must be a ssl.SSLContext instance...
    #      http.client.HTTPSConnection performs all the necessary certificate and hostname checks by default.

    if download.insecure:
        return ssl._create_unverified_context()

    return None


def collectResponseHeaders(download, response):
    download.responseHeaders = response.info()
    if download.responseHeaders.get("ETag"):
        download.etag = download.responseHeaders.get("ETag").strip('"')


def handleHTTPErrorAttempt(download, httpError):
    if httpError.code == 416:  # 416 is Range Not Satisfiable
        # likely the file completely downloaded and validation was interrupted,
        # therefore calling it successfully downloaded and allowing validation
        # to say otherwise
        handleSuccessfulAttempt(download)
    else:
        handleRecoverableAttempt(download, httpError)


def handleRecoverableAttempt(download, error):
    stopAnimateDownload("error")

    print(
        "failure on attempt {} downloading {}: {}".format(
            download.attemptNumber, download.filename, error
        )
    )

    if download.attemptNumber < download.attemptMax:
        sleepBeforeNextAttempt(download)
        download.attemptNumber += 1
    else:
        download.attempt = False
        download.error = error


def sleepBeforeNextAttempt(download):
    sleepSeconds = download.initialSleepSeconds * (
        download.sleepMultiplier ** (download.attemptNumber - 1)
    )

    if sleepSeconds > download.sleepMaxSeconds:
        sleepSeconds = download.sleepMaxSeconds

    print(
        "waiting {} seconds before next attempt to download {}".format(
            sleepSeconds, download.filename
        )
    )
    time.sleep(sleepSeconds)


def handleIrrecoverableAttempt(download, error):
    stopAnimateDownload("error")

    download.attempt = False
    download.error = error


def handleSuccessfulAttempt(download):
    stopAnimateDownload("done")

    download.attempt = False
    download.success = True


def validateFile(download):
    try:
        validateAllSteps(download)
    except InvalidDownload as error:
        download.valid = False
        download.vwarning = str(error)
    except Exception as error:
        download.valid = False
        download.verror = error
    else:
        download.valid = True


def validateAllSteps(download):
    verrorData = validatePerData(download)
    verrorEtag = validatePerEtag(download)
    verrorStale = validateStaleness(download)

    if verrorData and verrorEtag:
        raise verrorData

    if verrorStale:
        raise verrorStale


def validatePerData(download):
    try:
        validateBytes(download)
        validateChecksum(download)
    except InvalidDownload as error:
        return error
    else:
        return None


def validateBytes(download):
    size = os.path.getsize(download.filenamePart)
    if not download.bytes == size:
        raise InvalidSizeValue(download, size)


def validateChecksum(download):
    if download.md5Checksum:
        md5Checksum = readMd5Checksum(download)
        if not download.md5Checksum == md5Checksum:
            raise InvalidChecksumValue(download, md5Checksum)
    else:
        raise UnableToPerformChecksum(download)


def readMd5Checksum(download):
    hash_md5 = hashlib.md5()

    with open(download.filenamePart, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)

    return hash_md5.hexdigest()


def validatePerEtag(download):
    try:
        validateChecksumEtag(download)
    except InvalidDownload as error:
        return error
    else:
        return None


def validateChecksumEtag(download):
    if isEtagChecksum(download):
        md5Checksum = readMd5Checksum(download)
        if not download.etag == md5Checksum:
            raise InvalidChecksumValuePerEtag(download, md5Checksum)
    else:
        raise UnableToPerformChecksum(download)


def isEtagChecksum(download):
    return download.etag and re.fullmatch(r"[a-z0-9]+", download.etag)


def validateStaleness(download):
    try:
        validateStaleChecksum(download)
    except InvalidDownload as error:
        return error
    else:
        return None


def validateStaleChecksum(download):
    if isEtagChecksum(download):
        if not download.md5Checksum or download.md5Checksum != download.etag:
            raise StaleChecksumValue(download)


class InvalidDownload(Exception):
    pass


class InvalidSizeValue(InvalidDownload):
    def __init__(self, download, actual):
        super().__init__(
            "invalid byte size: downloaded file is {} bytes but should be {}".format(
                actual, download.bytes
            )
        )


class InvalidChecksumValue(InvalidDownload):
    def __init__(self, download, actual):
        super().__init__(
            "invalid checksum: downloaded file is {} but should be {}".format(
                actual, download.md5Checksum
            )
        )


class InvalidChecksumValuePerEtag(InvalidDownload):
    def __init__(self, download, actual):
        super().__init__(
            "invalid checksum: downloaded file is {} but should be {} according to server".format(
                actual, download.etag
            )
        )


class UnableToPerformChecksum(InvalidDownload):
    def __init__(self, download):
        super().__init__("cannot verify checksum")


class StaleChecksumValue(InvalidDownload):
    def __init__(self, download):
        super().__init__("checksum value has changed")


class Download:
    def __init__(self, args, datum):
        self.apiToken = args.get("apiToken")
        self.userAgent = args.get("userAgent")
        self.attemptMax = args.get("attemptMax")
        self.initialSleepSeconds = args.get("initialSleepSeconds")
        self.sleepMultiplier = args.get("sleepMultiplier")
        self.sleepMaxSeconds = args.get("sleepMaxSeconds")
        self.insecure = args.get("insecure")

        self.url = datum.get("url")
        self.filename = datum.get("filename")
        self.bytes = int(datum.get("bytes"))
        self.md5Checksum = datum.get("md5Checksum")

        self.filenamePart = self.filename + ".part"
        self.success = False
        self.attempt = True
        self.attemptNumber = 1
        self.responseHeaders = {}
        self.etag = None
        self.error = None
        self.valid = False
        self.vwarning = None
        self.verror = None

    def __str__(self):
        return f"url: {self.url}, filename: {self.filename}, bytes: {self.bytes}, md5Checksum: {self.md5Checksum}"


if __name__ == "__main__":
    main(data)
